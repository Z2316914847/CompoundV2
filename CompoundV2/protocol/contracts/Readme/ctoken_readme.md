# CToken 合约文档
目录：
一：合约概述
二：合约状态变量
三：合约核心函数
四：重要机制详解（个人认为这里是首先需要了解的）

## 一：合约概述

### 1.2 合约简介
CToken 是 Compound 协议的 **核心合约**，代表了用户在 Compound 协议中存入资产后 **获得** 的凭证代币。每个 CToken 对应一种特定的底层资产（如 USDC、DAI、ETH 等）。用户存入底层资产后会获得 CToken，这些 CToken 可以用来赎回底层资产、作为借款抵押品，并且会随时间自动累积利息。

### 继承
CToken 继承自：
├── CTokenInterface - CToken 接口定义
├── ExponentialNoError - 指数运算库（无错误版本）
└── TokenErrorReporter - 错误报告器

## 二：合约状态变量
基础变量
关联合约变量
配置参数变量
资产相关变量
用户数据映射变量

## 三：合约核心函数

### 1、ERC-20 代币功能模块
### 2、存款（Mint）模块
### 3、赎回（Redeem）模块
### 4、借款（Borrow）模块
### 5、偿还借款（Repay Borrow）模块
### 6、清算借款（Liquidate Borrow）模块
### 7、利息累积模块
### 8、兑换率与利率查询模块
### 9、管理员功能模块
### 10、虚拟函数（需要子合约实现
### 11、重入防护
### 12、未知模块（以后更新这些函数的作用）

## 四：重要机制详解
首先的了解几个公式：
资金使用率：`U = totalBorrows / (totalCash + totalBorrows - totalReserves)`
借贷利率:不方便写公式，各位可以去查以下百度，你也可以看我的 **compound学习文章：https://github.com/Z2316914847/foundry_Study/blob/main/task/day12/article/compound%E5%AD%A6%E4%B9%A0.md**
存款利率：同上
结算总还款和总存款：同上

### 1、兑换率的作用
兑换率 决定了 CToken 和 底层资产 之间的兑换比例，是 Compound 协议实现 **存款收益** 的核心机制。
APY计算方式：（最新利息-上一次利息）/上一次利息

### 2、利息累积
怎么理解利息累计呢？要明白这个，首先的明白，利率是 **细分** 到区块上的：这样理解，在defi领域，利率是 **细分** 到区块上的：假如 年华利率20%，假如每一个小时出一个区块，那么每个区块利率 = 20% / (1 * 24 * 365) = 0.0000228 = 0.00228%。然后用户在借款、存款、还款时，会计算出从开始借款 - 还款这个期间的区块总利息，然后compound会结算利息，并将利息归到用户借贷金额中。
利息累积计算方式；borrowIndexNew = **borrowIndex** + **borrowIndex** x borrowRate × blockDelta

### 3、借贷余额计算
因为已经计算出了 **利息累计**，现在我们就计算借贷余额
计算方式：总欠款（借贷本金+利息） =  借款本金 × (当前累计利息 / 借款时的累计利息)

### 清算
借款价值 > 抵押品价值 × 抵押率
清算激励
  清算奖励5%-8%，其中协议会从清算奖励中抽取2.8%给协议储备金，所以清算人实际获得清算奖励为 2.2%-5.4%
- **清算折扣**: 通常为 8%，清算人以 92% 的价格获得抵押品
- **协议分成**: 清算所得的一部分（如 2.8%）归协议储备金

### 4、安全机制
ctoken严格遵守 检查-效果-交互模式
所有关键函数都使用 `nonReentrant` 修饰符，防止递归调用。
新鲜度检查：确保操作基于最新的利息累积状态（ require(accrualBlockNumber == getBlockNumber(), "Market not fresh") ）。
控制器检查：所有核心操作都需要通过控制器的授权：
  - `comptroller.mintAllowed()`
  - `comptroller.borrowAllowed()`
  - `comptroller.redeemAllowed()`
  - `comptroller.liquidateBorrowAllowed()`
Solidity 0.8+ 内置溢出检查，所有算术操作自动检查溢出。


# 走进 Ctoken
## ERC20代币功能模块（重点了解功能）
### initialize
最出的ctoken池子必定没人存款借款等等，一切都是最初的状态（我指的是状态变量）然后有人部署ctoken后的一瞬间：
- 管理员地址 = 部署ctoken的人 的地址    √
- 风险控制器 = 最新部署的合约           √
- 利率模型 = 最新部署的合约             √
- 每个区块最大借贷利率（不可变） = 0.0005e16 = 0.00005%       √
- 最大储备金系数（不可变） = 1e18 = 100e16 = 100%             √
- 协议清算分层 = 0.028e18 = 2.8e16 = 2.8%                    √
- 兑换率 = 0.02e18 = 2%           √
- 储备金系数 = 0.1e18 = 10%       为什么ctoken初始化不设置 储备金系数
- 记息区块 = block.number         √
- 累计利息 = 1e18                 √
- 借贷金额 = 0
- 储备金   = 0
- 总供应量 = 0
- 重入锁   = true

### transfer
##### 1、CToken 是抵押品，不是普通代币，你不能随意转移作为贷款抵押的质押物，因为这会影响到 compound 的资产质量和风险控制。
##### 2、为什么compound中的ctoken转账函数有四个参数，而普通erc20转账只有三个参数。
- 答：一个函数处理两种转账场景（普通转账、被授权人使用津贴进行转账）、明确区分调用者和发送方
##### 3、为什么转账需要检查
- 防止市场被停止
  - 维持系统稳定
    假如某一时刻用质押物暴跌50%，导致很多用户质押率不足，大量清算人清算借贷，这就会进一步质押物价格下跌（这个过程清算人可能也不盈利），这样就会给系统带来清算压力过大，形成恶性螺旋，最终导致系统崩溃。
- 防止用户逃离清算: 大致意思是,用户转移代币价值 + 借贷价值 > 质押价值,这是协议形成坏账.所以转账时要检查,以防止用户逃离清算.
##### 4、当某个代币价格暴跌时，compound协议会做什么应急措施？
你可能只会想到，compound会设置 停止清算，其他并不清楚。下面给你介绍详细情况：
- 1、compound会启用 全局暂停转账，目的是为了不让用户质押品逃离，减少协议形成坏账。
- 2、compound会启用 全局暂停扣押质押品(其实就是暂停清算)，目的是为了让用户对应突发情况
- 3、compound会启用 市场级别暂停借贷，目的是为了让用户账户健康、
- 4、compound会启用 市场级别暂停铸造，目的是为了防止保障用户权益：由于价格暴跌，可能代币价格不稳定，用户铸造代币的话，可能会损害用户资金
##### 5、转账时的检查 代码逻辑
- 检查市场是否被停止(含暂停检查、健康度检查、含COMP治理代币处理-supply)
- 计算用户转移代币后,账户健康度（这里会比较麻烦）
- Comp代币分发(Comp代币时治理代币), 
  - 为什么要分发Comp治理代币
    - 激励流动性供应
    - 去中性化治理
    - 价值捕获: 协议越成功 -> COMP治理代币 需求高 -> COMP治理代笔 价值推高
  - 分发 Comp治理代币逻辑
    - 每天总发放: 2,880 COMP => 每秒发放: 0.0333 COMP
    - 分配规则: 
    50% (1,440 COMP/天) → 供应者（存款人）
    50% (1,440 COMP/天) → 借款人
    - 各市场独立分配,例如: 
    cUSDC: 1000 COMP/天 → 供应者
    cDAI:  800 COMP/天  → 供应者
  - 用户应得 COMP = 用户持有 cToken × (当前指数 - 用户上次快照指数)
  - COMP治理代币 分发时机
    - mint()        - 存款
    - redeem()      - 取款
    - borrow()      - 借款
    - repayBorrow() - 还款
    - transfer()    - 转账
### balanceOfUnderlying
##### 计算用户底层资产 = 用户持有ctoken * 最新汇率
  - 获取最新兑汇率 = ( 池子内当前最新底层资产余额 + 池子内当前最新 所有借款人的总借款额 - 池子内最新协议存储金 ）/ 已发行的cToken总量
##### 为什么兑换率不存储起来
  - 因为用户查询兑换率的操作，并不是同一时刻，所以兑换率要实时计算，如果不实时计算，会影响用户资产。
##### 我一直有一个疑惑，总贷款是如何正确计算的？
你首先得理解这些：accrueInterest() 和 用户只计算自己的新借贷额度 和  totalBorrowsNew = totalBorrows + borrowAmount
- accrueInteres()方法在ctoken中被经常使用，六大模块都有使用，主要是更新：最新区块号, 最新借贷指数, 最新借贷总额, 最新储备金。
- 用户只计算自己的新借贷额度：用户自己计算出来的 新借贷额度 并不会用到 协议总借贷额度中。
- totalBorrowsNew = totalBorrows + borrowAmount：协议新总借贷额度 只会用accrueInterest()计算出来的借贷额度 和 用户新借贷数量
总结：通过accrueInterest()和totalBorrowsNew = totalBorrows + borrowAmount 正确计算出来的。
```
在这个样场景中：用户A在A时刻借贷100U、用户B在B时刻借贷100U，用户A在C时刻查询底层资产，用户A在D时刻借贷100U，总借贷正确计算方式：
1、A时刻：不用管，总借贷额度 = 100
2、B时刻：由于执行了accrueInteres()方法，B-A时间段得总借贷被更新 = 100+100*(B-C)，执行完borrowFresh()方法后，B时刻这个时间点，总借贷有被更新 = 100+100*(B-C)+100
3、C时刻：由于A-B利息已经算了，所以只要算B-C时刻利息即可,然后B时刻总借贷额度+B-C得利息，就得到C时刻得总借贷额度。
4、D时刻：同理
```

##### 涉及的公式有：
  - 资金使用率
  - 每个区块利率
  - 这段时间的累计利率
  - 这段时间的累计利息
  - 这段时间借贷总额（含利息）
  - 最新储备金
  - 最新累计利息指数


## 存款（Mint）模块（重点了解功能）
- 用户获取ctoken方式：用户直接和ctoken合约交互：用户携带底层资产直接调用ctoken合约铸造功能，而ctoken合约给用户铸造等价的ctoken代币。
### mintFresh 是存款核心逻辑
- 1、权限检查(含暂停检查、含COMP治理代币处理-supply)
- 2、计算兑换率
- 3、计算应该赎回底层资产数量
- 4、更新状态：accrueInterest()、COMP治理代币级别（待细究）、ctoken总供应量、账户ctoken数量
##### 一个用户存款到ctoken中，不就是变更底层资产和铸造ctoken，为什么还要调用accrueInterest()
- 因为，使用到了兑换率，兑换率又要使用最新数据（底层资产，总借贷等），所以要调用accrueInterest()方法
##### 为什么 mintAllowed 和 transferAllowed 检查的市场暂停变量不一样？又为什么一个是单个，一个是映射。
- 检查的市场暂停变量不一样：是因为一个是mint，一个是transfer，他们本来就不同，所有检查的市场暂停变量就不一样。注意：Mint/Borrow （按市场隔离），Transfer/seize （全局暂停）
- 为什么一个是单个，一个是映射：是因为mint/borrow影响有限，如果一个市场mint有问题，其他市场正常，难道你会选择暂停所有市场的铸造功能吗，肯定不会啊，因为不合理。借贷同理。transfer/seize设置必须设置全局，因为它主要是为了代币价格暴跌，如果设置市场界别暂停的话，这么多市场，管理员要设置到 `过年哦`，管理员还有可能漏掉某个市场没有设置暂停，导致没有设置暂停的市场 ，对应代币价格暴跌，最后螺旋死亡。
##### 为什么 transferAllowed 检查市场停止不使用市场级别？而是 使用全局暂停？ 
其实上面已经介绍了，这里只是补充一点：：清算时所有抵押品都可用于清算。

```
设想Bob资产
  市场A：质押100USDC，得到100ctoken (转账设置为市场级别暂停)
  市场B：质押50DAI，得到50CDAI，
  用户借贷80USDC，这时账户是安全的。因为 质押率 = 质押品价值 / 借贷价值 = 135 / 80 = 168.75%
  用户将50CDAI转到其他账户，用户Bob资产：
  市场A：100USDC，得到100ctoken
  市场B：0CDAI，
  用户借贷还是80USDC，这时账户也是安全的。因为 质押率 = 质押品价值 / 借贷价值 = 90 / 80 = 112.5%
  就在某个时间点（这个 某个时间点 贯传始末，但在用户转移50CDAI时，这是账户才不健康，这是检测到账户应该清算，才会有后续故事） USDC 价格下跌，从 1->0.7，用户质押品早已触发清算，清算人 要 清算用户Bob 质押品，但是由于 转账设置为了市场级别暂停，导致清算人无法清算用户Bob，由于用户Bob质押价值（清算时所有抵押品都可用于清算）低于借贷价值，这个时候市场就形成了坏账。
```
因为全局暂停，可以阻止用户Bob将DAI转移出去，进而就不会形成坏账，因此 Transfer/Seize 必须使用全局布尔，而不是映射。


## 赎回（Redeem）模块（重点了解功能）
ctoken的铸造和转账都已经介绍完了。现在介绍赎回：因为用户获得到ctoken后，即就是用户将ctoken存款到市场中，存到市场有什么好处呢？以及用户如何赎回自己的底层资产？
- ctoken存到市场的好处：ctoken会生息、能获得COMP治理代币、作为抵押品，进行借贷
下面介绍赎回功能
### redeemFresh 是赎回核心逻辑
赎回这个操作不能被暂停：因为必须遵循用户可以自己掌控自己的资产，如果用户都不能控制这个资产，用户都不敢用这个协议。
- 1、兑换率获取(不含暂停检查，含账户健康度检查、含COMP治理代币处理-borrow)
- 2、计算应该赎回底层资产数量
- 3、权限检查(不含暂停检查、含健康度检查、COMP治理代币处理)
- 4、更新状态：accrueInterest()、COMP治理代币级别（待细究）、ctoken总供应量、账户ctoken数量
- 5、转出底层资产


## 借款（Borrow）模块（重点了解功能）
- 我们想要借贷成功，那么我们必须有资产在compound中，并且借贷后账户必须是健康的。
- 用户在这个市场借贷，用户必须加入到这个市场，用户加入这个市场=》说明用户这个市场的质押物被归入流动性计算中，如果没加入这个市场，那么用户这个市场的资产不规流动性假设。加入这个市场的标识：是指markets[ctoken].accountMembership[borrower] = true。如何然他变为true呢？用户手动调用CompTroller合约的enterMakets方法（这个方法就是让用户加入到市场中）,获取用户首次在这个市场进行借贷，借贷过程中，用户会添加到市场汇总。
- **用户处理的是ctoken还是底层资产**
  - transfer：转账处理的是ctoken
  - mint：用户转入底层资产，获取ctoken
  - redeem：获取底层资产，函数参数可以是底层资产，也可以是ctoken
  - borrow：借贷是底层资产,函数参数也是底层资产
  - repay：还款 还的是底层资产，函数参数是底层资产
  - liquidate：清算人得到是ctoken，函数参数是底层资产
### borrowFresh 是借贷核心逻辑
- 1、权限检查(含停止暂停，含账户健康度检查、含COMP治理代币处理-borrow)
- 2、获取用户最新借贷总额（不含这次借贷数量）
- 3、计算最新借贷总额（含这次借贷数量）
- 4、计算市场借贷总额
- 5、更新状态：accrueInterest()、COMP治理代币级别（待细究）、最新欠款额度、最新用户级别累计利息、总欠款额度
##### borrowIndex借贷指数 和 用户级别的 BorrowSnapshot.interestIndex有什么区别？
| 特性	    | borrowIndex	          | BorrowSnapshot.interestIndex
| 范围	    | 全局市场级别	         | 单个用户级别
| 更新频率	| 每次计息时更新	       | 仅用户借款/还款时更新
| 作用	    | 反映市场累积利率	     | 记录用户操作时的利率基准点
| 增长性	  | 持续增长	             | 固定值（直到下次用户操作）


## 偿还借款（Repay Borrow）模块（重点了解功能）
- 不知道你有没有注意到，每个模块都会调用 accrueInterest() 利息累计这个函数。其实这些模块执行前都会 更新 利息累计。
- 为什么这里要调用 accrueInterest(), 用户还款的话 ——》要计算用户贷款所产生的利息 ——》那么必须用到最新的 borrowIndex ——》所以要调用 accrueInterest()
### repayBorrowFresh 是偿还核心逻辑
偿还逻辑不需要检查账户健康度，主要是检查账户是否有足够的代币用于偿还。
- 1、检查权限(不含暂停检查和账户健康度检查、含COMP治理代币处理-borrow)
- 2、获取最新欠款总额
- 3、更新状态：accrueInterest()、COMP治理代币级别（待细究）、最新欠款额度、最新用户级别累计利息、总欠款额度


## 清算借款（Liquidate Borrow）模块（重点了解功能）
用户A质押1个ETH，1个ETH = 3000U，质押率>=75%时触发清算，最多可以清算50%。现在用户A借贷1800U
```
1、用户A质押率 = 1800/3000 = 60%    // 不会触发清算，当ETH价格下跌至2400时，且用户A质押价值和借贷价值没有变，则会触发用户A清算
2、某一时刻 ETH 暴跌，ETH = 2400
3、清算人给借贷人偿还50%：1800U * 50% = 900U
4、用户A被扣押： 900U * 1.08 = 972U（其中2.8%规协议，剩余的奖励规清算人）
5、用户A剩余 ETH = 1ETH - 被扣押的ETH = 1 - 972/2400 = 1 - 0.405 = 0.595ETH
6、用户被清算后实际资产（按U计算） = 用户最新借贷 + 质押 = 900U +0.595ETH * 2400 = 900+1428 = 2328U
7、所以用户被清算了72U，剩余2328U

```
### liquidateBorrowFresh 是清算核心逻辑
- 1、检查权限(不含暂停检查、含账户健康度检查、含一个偿还金额 < 最大可清算额度)
- 2、计算 实际 偿还ctoken数量
- 3、根据偿还ctoken数量 计算出 将要扣押的质押品
- 4、执行扣押，清算人获取清算奖励、协议获取清算奖励。
##### 执行两次 accrueInterest() 这是为什么？
- 
### seizeInternal 是 扣押质押品 核心逻辑
- 1、权限检查（含暂停检查、不含健康度检查、含COMP治理代币处理-supply）
- 2、计算出 协议清算奖励和清算人奖励
- 3、更新状态：储备金、ctoken供应量、借贷人ctoken减少、清算人ctoken增加
##### 为什么 扣押 还要权限检查？
- 有的极端情况下，底层资产代币价格暴跌，导致许多用户将要被清算，给协议系统带来巨大的清算压力，由于代币价格暴跌，清算人清算的奖励将会出售，这回导致代币价格进一步下跌，造成螺旋死亡。**暂停全局扣押就是为了暂时不然扣押，也就是不让清算，让用户有时间应对。从而保障用户权益。**
##### 所以：储备金是已底层资产存在，并不是以ctoken形式存在
##### 清算人最后得到 Ctoken，协议得到的分成，化为储备金，最后转为 底层资产。最后用户失去得也是ctoken




