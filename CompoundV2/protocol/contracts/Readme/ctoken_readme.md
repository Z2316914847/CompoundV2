# CToken 合约文档
目录：
一：合约概述
二：合约状态变量
三：合约核心函数
四：重要机制详解（个人认为这里是首先需要了解的）

## 一：合约概述

### 1.2 合约简介
CToken 是 Compound 协议的 **核心合约**，代表了用户在 Compound 协议中存入资产后 **获得** 的凭证代币。每个 CToken 对应一种特定的底层资产（如 USDC、DAI、ETH 等）。用户存入底层资产后会获得 CToken，这些 CToken 可以用来赎回底层资产、作为借款抵押品，并且会随时间自动累积利息。

### 继承
CToken 继承自：
├── CTokenInterface - CToken 接口定义
├── ExponentialNoError - 指数运算库（无错误版本）
└── TokenErrorReporter - 错误报告器

## 二：合约状态变量
基础变量
关联合约变量
配置参数变量
资产相关变量
用户数据映射变量

## 三：合约核心函数

### 1、ERC-20 代币功能模块
### 2、存款（Mint）模块
### 3、赎回（Redeem）模块
### 4、借款（Borrow）模块
### 5、偿还借款（Repay Borrow）模块
### 6、清算借款（Liquidate Borrow）模块
### 7、利息累积模块
### 8、兑换率与利率查询模块
### 9、管理员功能模块
### 10、虚拟函数（需要子合约实现
### 11、重入防护
### 12、未知模块（以后更新这些函数的作用）

## 四：重要机制详解
首先的了解几个公式：
资金使用率：`U = totalBorrows / (totalCash + totalBorrows - totalReserves)`
借贷利率:不方便写公式，各位可以去查以下百度，你也可以看我的 **compound学习文章：https://github.com/Z2316914847/foundry_Study/blob/main/task/day12/article/compound%E5%AD%A6%E4%B9%A0.md**
存款利率：同上
结算总还款和总存款：同上

### 1、兑换率的作用
兑换率 决定了 CToken 和 底层资产 之间的兑换比例，是 Compound 协议实现 **存款收益** 的核心机制。
APY计算方式：（最新利息-上一次利息）/上一次利息

### 2、利息累积
怎么理解利息累计呢？要明白这个，首先的明白，利率是 **细分** 到区块上的：这样理解，在defi领域，利率是 **细分** 到区块上的：假如 年华利率20%，假如每一个小时出一个区块，那么每个区块利率 = 20% / (1 * 24 * 365) = 0.0000228 = 0.00228%。然后用户在借款、存款、还款时，会计算出从开始借款 - 还款这个期间的区块总利息，然后compound会结算利息，并将利息归到用户借贷金额中。
利息累积计算方式；borrowIndexNew = **borrowIndex** + **borrowIndex** x borrowRate × blockDelta

### 3、借贷余额计算
因为已经计算出了 **利息累计**，现在我们就计算借贷余额
计算方式：总欠款（借贷本金+利息） =  借款本金 × (当前累计利息 / 借款时的累计利息)

### 清算
借款价值 > 抵押品价值 × 抵押率
清算激励
  清算奖励5%-8%，其中协议会从清算奖励中抽取2.8%给协议储备金，所以清算人实际获得清算奖励为 2.2%-5.4%
- **清算折扣**: 通常为 8%，清算人以 92% 的价格获得抵押品
- **协议分成**: 清算所得的一部分（如 2.8%）归协议储备金

### 4、安全机制
ctoken严格遵守 检查-效果-交互模式
所有关键函数都使用 `nonReentrant` 修饰符，防止递归调用。
新鲜度检查：确保操作基于最新的利息累积状态（ require(accrualBlockNumber == getBlockNumber(), "Market not fresh") ）。
控制器检查：所有核心操作都需要通过控制器的授权：
  - `comptroller.mintAllowed()`
  - `comptroller.borrowAllowed()`
  - `comptroller.redeemAllowed()`
  - `comptroller.liquidateBorrowAllowed()`
Solidity 0.8+ 内置溢出检查，所有算术操作自动检查溢出。


# 走进 Ctoken
## ERC20代币功能模块（重点了解功能）
### initialize
最出的ctoken池子必定没人存款借款等等，一切都是最初的状态（我指的是状态变量）然后有人部署ctoken后的一瞬间：
- 管理员地址 = 部署ctoken的人 的地址    √
- 风险控制器 = 最新部署的合约           √
- 利率模型 = 最新部署的合约             √
- 每个区块最大借贷利率（不可变） = 0.0005e16 = 0.00005%       √
- 最大储备金系数（不可变） = 1e18 = 100e16 = 100%             √
- 协议清算分层 = 0.028e18 = 2.8e16 = 2.8%                    √
- 兑换率 = 0.02e18 = 2%           √
- 储备金系数 = 0.1e18 = 10%       为什么ctoken初始化不设置 储备金系数
- 记息区块 = block.number         √
- 累计利息 = 1e18                 √
- 借贷金额 = 0
- 储备金   = 0
- 总供应量 = 0
- 重入锁   = true

### transfer
##### 1、CToken 是抵押品，不是普通代币，你不能随意转移作为贷款抵押的质押物，因为这会影响到 compound 的资产质量和风险控制。
##### 2、为什么compound中的ctoken转账函数有四个参数，而普通erc20转账只有三个参数。
- 答：一个函数处理两种转账场景（普通转账、被授权人使用津贴进行转账）、明确区分调用者和发送方
##### 3、为什么转账需要检查
- 防止市场被停止
  - 维持系统稳定
    - 假如某一时刻用质押物暴跌50%，导致很多用户质押率不足，大量清算人清算借贷，这就会进一步质押物价格下跌（这个过程清算人可能也不盈利），这样就会给系统带来清算压力过大，形成恶性螺旋，最终导致系统崩溃。
  - 暂停市场会限制这些功能：转账、借贷、清算。其他功能能正常使用。
- 防止用户逃离清算: 大致意思是,用户转移代币价值 + 借贷价值 > 质押价值,这是协议形成坏账.所以转账时要检查,以防止用户逃离清算.
##### 4、转账时的检查 代码逻辑
- 检查市场是否被停止
- 计算用户转移代币后,账户健康度（这里会比较麻烦）
- Comp代币分发(Comp代币时治理代币), 
  - 为什么要分发Comp治理代币
    - 激励流动性供应
    - 去中性化治理
    - 价值捕获: 协议越成功 -> COMP治理代币 需求高 -> COMP治理代笔 价值推高
  - 分发 Comp治理代币逻辑
    - 每天总发放: 2,880 COMP => 每秒发放: 0.0333 COMP
    - 分配规则: 
    50% (1,440 COMP/天) → 供应者（存款人）
    50% (1,440 COMP/天) → 借款人
    - 各市场独立分配,例如: 
    cUSDC: 1000 COMP/天 → 供应者
    cDAI:  800 COMP/天  → 供应者
  - 用户应得 COMP = 用户持有 cToken × (当前指数 - 用户上次快照指数)
  - COMP治理代币 分发时机
    - mint()        - 存款
    - redeem()      - 取款
    - borrow()      - 借款
    - repayBorrow() - 还款
    - transfer()    - 转账

### balanceOfUnderlying
##### 计算用户底层资产 = 用户持有ctoken * 最新汇率
  - 获取最新兑汇率 = ( 池子内当前最新底层资产余额 + 池子内当前最新 所有借款人的总借款额 - 池子内最新协议存储金 ）/ 已发行的cToken总量
##### 为什么兑换率不存储起来
  - 因为用户查询兑换率的操作，并不是同一时刻，所以兑换率要实时计算，如果不实时计算，会影响用户资产。
##### 涉及的公式有：
  - 资金使用率
  - 每个区块利率
  - 这段时间的累计利率
  - 这段时间的累计利息
  - 这段时间借贷总额（含利息）
  - 最新储备金
  - 最新累计利息指数

## 存款（Mint）模块（重点了解功能）
- 用户获取ctoken方式：用户直接和ctoken合约交互：用户携带底层资产直接调用ctoken合约铸造功能，而ctoken合约给用户铸造等价的ctoken代币。
### mintFresh 是存款核心逻辑
- 1、权限检查(含暂停检查、含COMP治理代币处理)
- 2、计算兑换率
- 3、计算应该赎回底层资产数量
- 4、更新状态：accrueInterest()、COMP治理代币级别（待细究）、ctoken总供应量、账户ctoken数量
##### 一个用户存款到ctoken中，不就是变更底层资产和铸造ctoken，为什么还要调用accrueInterest()
- 因为，使用到了兑换率，要使用最新数据，所以要调用accrueInterest()方法
##### 铸造执行的检查和转账执行的检查方法分别是，comptroller.mintAllowed()、comptroller.transferAllowed()，所以他们代码逻辑会有区别，接下来介绍铸造 mintAllowed() 代码逻辑
- 市场检查是否停止
- Comp代币分发(Comp代币时治理代币), 
##### 为什么 mintAllowed 和 transferAllowed 检查的市场停止变量不一样？一个是单个，一个是映射。
- Mint/Borrow 风险有限，可按市场隔离
- Transfer 关闭时全面停止，防止套利与清算规
##### 为什么 transferAllowed 检查市场停止不使用市场级别？而是 使用全局暂停？ 
首先的明白：清算时所有抵押品都可用于清算
```
设想Bob资产
  市场A：质押100USDC，得到100ctoken (转账设置为市场级别暂停)
  市场B：质押50DAI，得到50CDAI，
  用户借贷80USDC，这时账户是安全的。因为 质押率 = 质押品价值 / 借贷价值 = 135 / 80 = 168.75%
  用户将50CDAI转到其他账户，用户Bob资产：
  市场A：100USDC，得到100ctoken
  市场B：0CDAI，
  用户借贷还是80USDC，这时账户也是安全的。因为 质押率 = 质押品价值 / 借贷价值 = 90 / 80 = 112.5%
  就在某个时间点（这个 某个时间点 贯传始末，但在用户转移50CDAI时，这是账户才不健康，这是检测到账户应该清算，才会有后续故事） USDC 价格下跌，从 1->0.7，用户质押品早已触发清算，清算人 要 清算用户Bob 质押品，但是由于 转账设置为了市场级别暂停，导致清算人无法清算用户Bob，由于用户Bob质押价值（清算时所有抵押品都可用于清算）低于借贷价值，这个时候市场就形成了坏账。
```
因为全局暂停，可以阻止用户Bob将DAI转移出去，进而就不会形成坏账，因此 Transfer/Seize 必须使用全局布尔，而不是映射。

## 赎回（Redeem）模块（重点了解功能）
ctoken的铸造和转账都已经介绍完了。现在介绍赎回：因为用户获得到ctoken后，即就是用户将ctoken存款到市场中，存到市场有什么好处呢？以及用户如何赎回自己的底层资产？
- ctoken存到市场的好处：ctoken会生息、能获得COMP治理代币、作为抵押品，进行借贷
下面介绍赎回功能
### redeemFresh 是赎回核心逻辑
赎回这个操作不能被暂停：因为必须遵循用户可以自己掌控自己的资产，如果用户都不能控制这个资产，用户都不敢用这个协议。
- 1、兑换率获取
- 2、计算应该赎回底层资产数量
- 3、权限检查(不含暂停检查、含健康度检查、COMP治理代币处理)
- 4、更新状态：accrueInterest()、COMP治理代币级别（待细究）、ctoken总供应量、账户ctoken数量
- 5、转出底层资产

## 借款（Borrow）模块（重点了解功能）
我们想要借贷成功，那么我们必须有资产在compound中，并且借贷后账户必须是健康的。
### borrowFresh 是借贷核心逻辑
- 1、权限检查(含停止暂停，含账户健康度检查、含COMP治理代币处理)
- 2、获取用户最新借贷总额（不含这次借贷数量）
- 3、计算最新借贷总额（含这次借贷数量）
- 4、计算市场借贷总额
- 5、更新状态：accrueInterest()、COMP治理代币级别（待细究）、最新欠款额度、最新用户级别累计利息、总欠款额度
##### borrowIndex借贷指数 和 用户级别的 BorrowSnapshot.interestIndex有什么区别？
| 特性	    | borrowIndex	          | BorrowSnapshot.interestIndex
| 范围	    | 全局市场级别	         | 单个用户级别
| 更新频率	| 每次计息时更新	       | 仅用户借款/还款时更新
| 作用	    | 反映市场累积利率	     | 记录用户操作时的利率基准点
| 增长性	  | 持续增长	             | 固定值（直到下次用户操作）

## 偿还借款（Repay Borrow）模块（重点了解功能）
- 不知道你有没有注意到，每个模块都会调用 accrueInterest() 利息累计这个函数。其实这些模块执行前都会 更新 利息累计。
- 为什么这里要调用 accrueInterest(), 用户还款的话 ——》要计算用户贷款所产生的利息 ——》那么必须用到最新的 borrowIndex ——》所以要调用 accrueInterest()
### repayBorrowFresh 是偿还核心逻辑
偿还逻辑不需要检查账户健康度，主要是检查账户是否有足够的代币用于偿还。
- 1、检查权限(不含暂停检查和账户健康度检查、含COMP治理代币处理)
- 2、获取最新欠款总额
- 3、更新状态：accrueInterest()、COMP治理代币级别（待细究）、最新欠款额度、最新用户级别累计利息、总欠款额度

## 清算借款（Liquidate Borrow）模块（重点了解功能）
### liquidateBorrowFresh 是清算核心逻辑
- 1、检查权限(不含暂停检查、含账户健康度检查)
- 2、计算 实际 偿还ctoken数量
- 3、根据偿还ctoken数量 计算出 将要扣押的质押品
- 4、执行扣押，清算人获取清算奖励、协议获取清算奖励。
##### 执行两次 accrueInterest() 这是为什么？
- 
### seizeInternal 是 扣押质押品 核心逻辑
- 1、权限检查（含暂停检查、不含健康度检查、含COMP治理代币处理）
- 2、计算出 协议清算奖励和清算人奖励
- 3、更新状态：储备金、ctoken供应量、借贷人ctoken减少、清算人ctoken增加
##### 为什么 扣押 还要权限检查？
- 有的极端情况下，底层资产代币价格暴跌，导致许多用户将要被清算，给协议系统带来巨大的清算压力，由于代币价格暴跌，清算人清算的奖励将会出售，这回导致代币价格进一步下跌，造成螺旋死亡。**暂停全局扣押就是为了暂时不然扣押，也就是不让清算，让用户有时间应对。从而保障用户权益。**
##### 所以：储备金是已底层资产存在，并不是以ctoken形式存在




